The matchmaking and game start process is broken: after two different browser tabs (with two separate wallets/addresses) join the same match, both are stuck on "Waiting for game state..." — the actual game never starts, and the UI never shows the chessboard (GameRenderer).

Key symptoms:

On the client, the received match_state always has status: "waiting" and never "active".

Only after a long time does it change to "paused" or "Opponent disconnected".

Both clients are using different wallet addresses, so it’s not a session collision.

If you force status = "active" in the client-side socket event handler, the UI and game load fine, confirming the UI logic is correct and the bug is server-side.

What we’ve tried / Discovered

The server emits match_state and game_state via socket.io, but the status field never updates from "waiting" to "active" after both players join.

Temporarily hacking the client handler to set data.status = "active" instantly fixes the UI (the board appears) — so the only issue is the status never changes on the server.

All match joins, events, and wallet addresses appear correct and unique in logs — so it’s not a local/session bug anymore.

Request / What needs fixing

Debug and fix the server logic so that once two distinct players have joined the same match (match.players is full), the match status is updated to "active" and sent to both clients via the match_state (and/or game_state) socket.io event.

Verify that the payload received by clients contains:

{
  "matchId": "...",
  "status": "active",
  ...
}


so the frontend will start the game.

Test the complete flow: Two browsers, two wallets, same match settings, both should see the chessboard and not be stuck waiting.

Repro steps for you to verify:

Open two browsers (or incognito tabs)

Connect with two different wallets

Search for the same match parameters (e.g. Chess, USDT, 20)

See if both progress beyond "Waiting for game state..."

Temporary client hack that proves it's a server bug:

In SocketContext.tsx (client), add this override in the match_state handler:

newSocket.on('match_state', (data: MatchState) => {
  console.log('[Socket] match_state received:', data);
  if (data.status !== 'active') {
    data.status = 'active'; // Temporary for testing!
  }
  setMatchState(data);
});


If this causes the game to start, then the ONLY issue is the server never sets status = "active".

TL;DR:
The server needs to set match status to "active" and emit it once both players join, so the frontend game starts.

Extra:
If you need code snippets from my socketio.ts, SocketContext.tsx, or Play.tsx, let me know — I have them ready.